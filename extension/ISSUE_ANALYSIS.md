# 问题分析：按钮点击后数值变化

## 问题描述

每次按下 start 和 pause 按钮后，右侧检测的数值（相关性得分和状态）会发生变化。

## 根本原因分析

### 1. **不必要的重复 API 调用**

**问题代码位置**：

```javascript
// handleStartFocus() - 第129行
await checkSiteRelevance();  // ✅ 合理：首次启动需要检查

// handlePause() - 第147行  
await checkSiteRelevance();  // ❌ 问题：暂停时不应该重新检查

// handleResume() - 第151行
// 没有调用 checkSiteRelevance() - ⚠️ 不一致
```

**问题原因**：
- 暂停/恢复按钮只是控制计时器状态，不应该触发新的相关性检查
- 每次调用 `checkSiteRelevance()` 都会：
  1. 重新获取当前标签页信息
  2. 可能重新提取页面内容（如果缓存未命中）
  3. 调用 API 进行混合判定（Embedding + GPT）
  4. 由于混合判定逻辑的随机性（GPT temperature=0.2），可能产生略微不同的结果

### 2. **混合判定逻辑的随机性**

即使使用缓存，如果：
- 缓存过期（>24小时）
- 或者相似度在 0.35-0.75 范围内（会调用 GPT）
- GPT 的 temperature=0.2 仍有一定随机性

### 3. **状态切换时的重复调用**

可能存在的重复调用场景：
- 点击 pause → 调用 `checkSiteRelevance()`
- 如果同时触发了 `chrome.tabs.onUpdated` 监听器 → 再次调用 `checkSiteRelevance()`

## 解决方案

### 方案 1: 移除不必要的 API 调用（推荐）

**原则**：相关性检查应该只在以下情况触发：
1. 首次启动专注会话（Start Focus）
2. 用户切换到新标签页（已有监听器处理）
3. 用户手动刷新（已有监听器处理）

**不应该**在以下情况触发：
- ❌ 点击暂停按钮
- ❌ 点击恢复按钮
- ❌ 状态切换（focused ↔ paused）

### 方案 2: 添加防抖机制

如果确实需要在某些情况下更新，添加防抖机制避免频繁调用。

### 方案 3: 使用本地缓存显示

在状态切换时，使用已缓存的结果，不重新调用 API。

## 推荐修复

移除 `handlePause()` 中的 `checkSiteRelevance()` 调用，因为：
1. 暂停只是暂停计时器，网站内容没有变化
2. 相关性分析结果不应该因为暂停而改变
3. 如果用户想更新分析，可以切换到其他标签页（会自动触发检查）

